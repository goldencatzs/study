#函数探幽
内联函数：编译器使用相应的函数代码替换函数调用。函数声明和定义前加上inline

只有一行代码的小型、非递归函数适合作为内联函数

声明引用时必须进行初始化

可以通过初始化声明来设置引用，但不能通过赋值来设置

对于以下情况，函数的引用会生成临时变量：
1. 实参的类型正确，但不是左值
2. 实参的类型不正确，但可以转换为正确的类型

如果接受引用参数的函数意图是个性作为参数传递的变量，则创建临时变量将阻止这种意图的实现，解决方法是：禁止创建临时变量

默认参数：

*	要为某个参数设置默认值，则必须为它右边的所有参数提供默认值
*	只有原型指定默认值，函数定义不需要

###函数重载：

能够使用多个同名的函数，只需特征标不同（参数的数目和类型，const指针与非const指针也为不同特征标）

编译器在检查函数特征标时，将把类型引用和类型本身视为同一个特征标

函数的返回类型不同，不是重载

仅当函数基本上执行相同的任务，但使用不同形式的数据时，才应采用函数重载

C++编译器采用名称修饰或名称矫正来为标识重载的函数

###函数模板
模板允许以通用类型（而不是具体类型）的方式编写程序-->通用编程

模板并不创建任何函数，只是告诉编译器如何定义函数

template \<typename T\>

void Swap(T &a, T &b);

模板可重载

显示具体化

可以显示地指出对于某种类型进行特殊的操作

template <> void Swap<job>(job &a, job &b);

如果有多个原型，编译器在选择原型时，非模板版本优先于显示具体化和模板版本，显示具体化优先于使用模板生成的版本

显式实例化：直接命令编译器创建特定的实例

template void Swap<int>(int , int );

试图在同一个编程单元中使用同一种类型的显式实例和显式具体化将出错

隐式实例化、显式实例化和显式具体化统称为具体化，它们表示的都是使用具体类型的函数定义，而不是通用描述

重载解析：

1. 创建候选函数列表
2. 使用候选函数列表创建可行函数列表
3. 确定是否有最佳的可行函数

最佳到最差顺序如下：

1. 完全匹配，但常规函数优先于模板
2. 提升转换(char->int, short->int, float->double)
3. 标准转换(int->char, long->double)
4. 用户定义的转换

两个函数完全匹配时，仍可完成重载解析：指向非const数据的指针和引用优先与非const的指针和引用参数匹配；非模板函数优先于模板函数（包括显式具体化）

部分排序规则：用于找出最具体的模板的规则

一个函数要比其他函数都合适，其所有参数的匹配程度都必须不比其他函数差，同时至少有一个参数的匹配程度比其他函数都高