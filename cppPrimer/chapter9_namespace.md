#内存模型和名称空间
在包含头文件时，如果文件名在尖括号<>中，C++编译器将在存储标准头文件的主机系统的的文件系统中查找，如果使用双引号""，则编译器将首先查找当时的工作目录或源代码目录

作用域：描述了名称在文件的多大范围内可见

链接性：描述了名称如何在不同单元间共享，链接性为外部的名称可以文件间共享，链接性为内部的名称只能由一个文件的函数共享，自动变量没有链接性，不能共享

自动变量：1. auto 2. 省略auto关键字 3. register声明为寄存器变量

如果变量被存储在寄存器中，则没有内存址，因此不能将地址操作符用于寄存器变量

编译器将分配固定的内存块来存储所有的静态变量，这些变量在整个程序执行期间内一直存在

如果没有显式地初始化静态变量，编译器就将它设置为0

链接性为外部的静态持续变量：在代码块外面声明

链接性内内部的静态持续变量：在代码块外面声明，并加static限定符

没有链接性的静态持续变量：在代码块内声明，并使用static限定符

只能使用常量表达式初始化静态变量

C++可使用作用域解析操作符::来访问被隐藏的外部变量，使用变量的全局版本

引用声明：extern double a;//不能在引用声明中初始化变量

存储说明符：

*	auto
*	register
*	static
*	extern
*	mutable -->即使结构（或类）变量为const，其某个成员也可以被修改

cv限定符：

*	const
*	volatile -->表示即使程序代码没有对内存单元进行修改，其值也可能发生变化，比如硬件

const全局变量的链接性为内部，可以在所有文件中使用相同声明

extern const int states = 50;//state链接性为外部

所有函数的存储持续性都自动为静态的，在整个程序执行期间一直存在，默认链接性为外部，可以在文件间共享

可以加关键字static使函数的链接性为内部，注意：函数的声明和定义中都应加static

C++要求所有的内联函数定义必须相同

-	extern "C" void spiff (int); //C语言链接性
-	extern "C++" void spiff (int); //C++语言链接性
-	extern void spiff (int); //C++语言链接性

只能用常量表达式来初始化静态存储变量，因此使用new只能用于函数中

布局new操作符-使用指定位置的内存

char buffer[50];

int *p1 = new (buffer) int[20];

名称空间可以是全局的，也可以位为另一个名称空间中，但是不能位于代码块中

名称空间是开放的，可以把名称加入到已有的名称空间中

    namespace AA{
		double a;
    };
    namespace AA{
		int b;
	};

using声明使指定的标识符可用：using AA::a;

using编译指令使整个名称空间可用：using namespace AA;

函数中的局部变量名称将隐藏全局变量及用using编译指令导入的名称空间名，可使用AA::a来获取名称空间值，使用::a来获取全局变量值

注：如果函数中的局部变量与using声明导入的变量名相同，将会报错

可以给名称空间创建别名：

    namespace mvft = my_very_favorite_things;
    namespace MEF = myth::elements::fire;

未命名空间可以替代链接性为内部的静态变量

已命名空间可以替代链接性为外部的全局变量