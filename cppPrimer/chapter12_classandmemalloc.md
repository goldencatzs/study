#类和动态内存分配
__不能__在类声明中初始化静态成员变量，因为声明描述了如何分配内存，但并不分配内存

对于静态成员，可以在类声明之外使用单独的语句来进行初始化，因为静态类成员是单独存储的，而不是对象的组成部分

    int String::num_strings = 0;

静态数据成员在类声明中声明，在包含类方法的文件中初始化。初始化使用作用域操作符来指出静态成员所属的类。但如果静态成员是整型或枚举型const，则可以在类声明中初始化

C++自动提供下面成员函数：

-	默认构造函数，如果没有定义构造函数（没有参数，不执行任何操作）**只能**有一个默认构造函数
-	复制构造函数，如果没有定义
-	赋值操作符，如果没有定义
-	默认析构函数，如果没有定义
-	地址操作符，如果没有定义

复制构造函数：用于将一个对象复制到新创建的对象中，用于初始化过程中，而不是常规的赋值过程中

调用复制构造函数场景：

*	新建一个对象并将其初始化为同类现有对象
*	函数按值传递对象或函数返回对象时

默认的复制构造函数逐个复制非静态成员（浅复制），复制的是成员的值

显式复制构造函数：如果类中包含这样的静态数据成员，其值将在新对象被创建时发生变化，则应该提供一个显式复制构造函数来处理

深度复制，将指针指向的内容分配一块内存，并记录副本地址

如果类中包含了使用new初始化的指针成员，应当定义一个复制构造函数，以复制指向的数据，而不是指针

将已有的对象赋给另一个对象时，将使用重载的赋值操作符

重载时，C++区分常量和非常量函数的特征标

    const char & String::operator[] (int i) const;
    const char & String::operator[] (int i);

静态类成员函数

    static int HowMany() {return num_strings};

*	不能能过对象调用静态成员函数，实际上，静态成员函数甚至不能使用this指针
*	由于静态成员函数不与特定的对象相关联，因此只能使用静态数据成员

需显式地为使用布局new操作符创建的对象调用析构函数

成员初始化列表

    Queue::Queue(int qs) : qsize(qs), front(NULL), rear(NULL), items(0)
    {
    
    }

**只有**构造函数可以使用这种初始化列表句法，对于const类成员和被声明为引用的类成员，必须使用这种句法

因为引用与const数据类似，只能在被创建时进行初始化

对于本身就是类对象的成员来说，使用成员初始化列表的效率更高

