#复合类型
##数组
将sizeof操作符用于数组名，将得到整个数组中的字节数

如果只对数组的一部分进行初始化，则编译器将把其他元素设置为0

如果初始化数组时方括号[]内为空，C++编译器将计算元素个数

##字符串
C++对字符串长度没有限制

strlen()只计算可见的字符

cin.getline()将丢弃换行符

cin.get()将换行符保留在输入序列中

当get()读取空行后，将设置失效位，接下来的输入将会被阻断，可以使用cin.clear()来恢复输入

##结构
C++结构除了成员变量之外，还可以有成员函数，但通常被用于类中
##共用体
共用体(union)可存储不同的数据类型，但只能同时存储其中的一种类型

共用体的长度为其最大成员的长度
##枚举
为获取最大限度的可移植性，应将把非enum值赋给enum变量视为错误

枚举量是整型，可被提升为int类型，但int类型不能自动转换为枚举类型

没有为枚举本身定义算数运算

枚举的取值范围：

上限：找到大于枚举最大值的最小的2的幂，将它减1即为上限

下限：如果最小值不小于0，则下限为0，否则与上述相同，加负号

##指针
OOP强调在运行阶段（而不是编译阶段）进行决策，运行阶段提供了灵活性，可以根据当时的情况进行调整

C++在创建指针时，计算机会分配用来存储地址的内存，但不会分配用来存储指针所指向的数据的内存

一定要在对指针应用解除引用操作符（*）之前，将指针初始化为一个确定的、适当的地址

释放已经释放的内存块，结果将是不确定的

只能用delete来释放使用new分配的内存，对空指针使用delete是安全的

在编译时给数组分配内存被称为静态联编

在运行阶段选择数组长度并创建，为动态联编

new与delete的格式不匹配导致的后果是不确定的

将指针变量加1后，其增加的值等于指向的类型占用的字节数

指针与数组的区别：

1. 可以修改指针的值，而数组名是常量，不能修改
2. 对数组应用sizeof操作符得到的是数组的长度，而对指针应用sizeof得到的是指针的长度

如果要显示的是字符串的地址，必须将这种指针强制转换为另一种指针类型

##自动存储、静态存储和动态存储
自动存储：自动变量，是一个局部变量，其作用域为包含它的代码块

静态存储：在整个程序执行期间都存在（在函数外定义、在声明变量时使用static）

动态存储：new delete